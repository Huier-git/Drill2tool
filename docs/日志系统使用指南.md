# 统一日志系统使用指南

## 概述

项目已实现统一的日志输出系统，提供格式化、结构化的日志输出，便于调试和问题定位。

---

## 日志格式

所有日志输出统一格式：

```
[时间][级别][模块名称] 日志消息内容
```

### 示例输出

```
[16:35:12.456][INFO ][Main                ] ==================================
[16:35:12.457][INFO ][Main                ] 钻机采集控制系统 v2.0
[16:35:12.458][INFO ][Main                ] 启动时间: 2025-01-18 16:35:12
[16:35:12.890][DEBUG][VibrationWorker     ] Created. Default: 5000Hz, 3 channels
[16:35:13.125][WARN ][ZMotionDriver       ] Device not connected, retrying...
[16:35:13.200][ERROR][MdbWorker           ] Failed to read from serial port
[16:35:13.201][CRIT ][AcquisitionManager  ] Data acquisition stopped unexpectedly
```

### 格式说明

- **时间**：HH:mm:ss.zzz（时:分:秒.毫秒），精确到毫秒
- **级别**：5个字符宽度，左对齐
  - `DEBUG` - 调试信息
  - `INFO ` - 一般信息
  - `WARN ` - 警告信息
  - `ERROR` - 错误信息
  - `CRIT ` - 严重错误
- **模块名称**：20个字符宽度，超长自动截断为17字符+`...`
- **消息内容**：实际日志内容

---

## 使用方式

### 1. 基本用法（字符串消息）

```cpp
#include "Logger.h"

// 在源文件中使用
LOG_DEBUG("MyClass", "This is a debug message");
LOG_INFO("MyClass", "Operation completed successfully");
LOG_WARNING("MyClass", "Resource usage is high");
LOG_ERROR("MyClass", "Failed to open file");
LOG_CRITICAL("MyClass", "System is about to crash");
```

**输出示例**：
```
[16:35:12.123][DEBUG][MyClass             ] This is a debug message
[16:35:12.124][INFO ][MyClass             ] Operation completed successfully
[16:35:12.125][WARN ][MyClass             ] Resource usage is high
[16:35:12.126][ERROR][MyClass             ] Failed to open file
[16:35:12.127][CRIT ][MyClass             ] System is about to crash
```

---

### 2. 流式语法（推荐）

当需要输出变量值时，使用流式语法更方便：

```cpp
#include "Logger.h"

void MyClass::processData(int value)
{
    LOG_INFO_STREAM("MyClass") << "Processing data, value:" << value;

    double result = value * 1.5;
    LOG_DEBUG_STREAM("MyClass") << "Result calculated:" << result;

    if (result > 100) {
        LOG_WARNING_STREAM("MyClass") << "Result exceeds threshold:" << result;
    }
}
```

**输出示例**：
```
[16:35:12.200][INFO ][MyClass             ] Processing data, value: 42
[16:35:12.201][DEBUG][MyClass             ] Result calculated: 63.0
[16:35:12.202][WARN ][MyClass             ] Result exceeds threshold: 120.5
```

---

## 替换现有qDebug调用

### 替换规则

| 旧代码 | 新代码 | 说明 |
|-------|--------|------|
| `qDebug() << "message";` | `LOG_DEBUG("Module", "message");` | 基本替换 |
| `qDebug() << "Value:" << val;` | `LOG_DEBUG_STREAM("Module") << "Value:" << val;` | 流式输出 |
| `qWarning() << "message";` | `LOG_WARNING("Module", "message");` | 警告信息 |
| `qCritical() << "message";` | `LOG_ERROR("Module", "message");` | 错误信息 |
| `qInfo() << "message";` | `LOG_INFO("Module", "message");` | 一般信息 |

### 替换示例

#### 示例 1：简单日志

**旧代码**：
```cpp
qDebug() << "[VibrationWorker] Created. Default: 5000Hz, 3 channels";
```

**新代码**：
```cpp
LOG_DEBUG("VibrationWorker", "Created. Default: 5000Hz, 3 channels");
```

---

#### 示例 2：带变量的日志

**旧代码**：
```cpp
qDebug() << "[VibrationWorker] Card ID:" << m_cardId;
qDebug() << "[VibrationWorker] Port:" << m_port;
qDebug() << "[VibrationWorker] Sample Rate:" << m_sampleRate << "Hz";
```

**新代码**：
```cpp
LOG_DEBUG_STREAM("VibrationWorker") << "Card ID:" << m_cardId;
LOG_DEBUG_STREAM("VibrationWorker") << "Port:" << m_port;
LOG_DEBUG_STREAM("VibrationWorker") << "Sample Rate:" << m_sampleRate << "Hz";
```

---

#### 示例 3：格式化字符串

**旧代码**：
```cpp
qDebug() << QString("[%1] ArmGripController created, motor_id=%2")
    .arg(mechanismCodeString())
    .arg(m_motorId);
```

**新代码（方法1：保持QString格式化）**：
```cpp
LOG_DEBUG_STREAM("ArmGripController")
    << QString("[%1] ArmGripController created, motor_id=%2")
        .arg(mechanismCodeString())
        .arg(m_motorId);
```

**新代码（方法2：使用流式输出）**：
```cpp
LOG_DEBUG_STREAM("ArmGripController")
    << "ArmGripController created, mechanism:" << mechanismCodeString()
    << ", motor_id:" << m_motorId;
```

---

#### 示例 4：条件日志

**旧代码**：
```cpp
if (m_statusUpdateTimer->isActive()) {
    qDebug() << QString("[%1] Status update enabled, interval: %2ms")
        .arg(m_name)
        .arg(m_statusUpdateTimer->interval());
} else {
    qDebug() << QString("[%1] Status update disabled").arg(m_name);
}
```

**新代码**：
```cpp
if (m_statusUpdateTimer->isActive()) {
    LOG_DEBUG_STREAM(m_name)
        << "Status update enabled, interval:" << m_statusUpdateTimer->interval() << "ms";
} else {
    LOG_DEBUG(m_name.toStdString().c_str(), "Status update disabled");
}
```

---

## 模块名称约定

### 命名规则

1. **类名直接使用**：如 `"VibrationWorker"`, `"AcquisitionManager"`
2. **简短清晰**：避免过长的名称（建议 <15 字符）
3. **驼峰命名**：与类名保持一致

### 常用模块名

| 模块类别 | 模块名示例 |
|---------|-----------|
| UI页面 | `MainWindow`, `SensorPage`, `DatabasePage` |
| 数据采集 | `VibrationWorker`, `MdbWorker`, `MotorWorker` |
| 控制器 | `FeedController`, `RotationController`, `AutoDrillManager` |
| 数据库 | `DbWriter`, `DataQuerier` |
| 驱动 | `ZMotionDriver` |
| 管理器 | `AcquisitionManager`, `MotionLockManager` |

---

## 最佳实践

### 1. 选择合适的日志级别

```cpp
// DEBUG - 详细的调试信息，生产环境可能关闭
LOG_DEBUG_STREAM("MyClass") << "Loop iteration:" << i;

// INFO - 重要的业务流程节点
LOG_INFO("MyClass", "Data acquisition started");

// WARNING - 异常但可恢复的情况
LOG_WARNING_STREAM("MyClass") << "Connection timeout, retrying..." << retryCount;

// ERROR - 错误但程序可继续运行
LOG_ERROR("MyClass", "Failed to save file, data may be lost");

// CRITICAL - 严重错误，程序可能无法继续
LOG_CRITICAL("MyClass", "Out of memory, terminating");
```

---

### 2. 避免过度日志

**不好的做法**（过多无用日志）：
```cpp
LOG_DEBUG("MyClass", "Entering function");
LOG_DEBUG("MyClass", "Step 1 done");
LOG_DEBUG("MyClass", "Step 2 done");
LOG_DEBUG("MyClass", "Exiting function");
```

**好的做法**（关键信息点）：
```cpp
LOG_DEBUG_STREAM("MyClass") << "Processing" << itemCount << "items";
// ... 处理逻辑 ...
LOG_INFO_STREAM("MyClass") << "Completed processing," << successCount << "succeeded," << failedCount << "failed";
```

---

### 3. 在构造/析构中记录

```cpp
VibrationWorker::VibrationWorker(QObject* parent)
    : BaseWorker(parent)
{
    LOG_DEBUG_STREAM("VibrationWorker")
        << "Created. Sample Rate:" << m_sampleRate << "Hz, Channels:" << m_channelCount;
}

VibrationWorker::~VibrationWorker()
{
    LOG_DEBUG("VibrationWorker", "Shutting down...");
    // ... 清理代码 ...
    LOG_DEBUG("VibrationWorker", "Shutdown complete");
}
```

---

### 4. 记录错误上下文

**不好的做法**：
```cpp
LOG_ERROR("MyClass", "Operation failed");
```

**好的做法**：
```cpp
LOG_ERROR_STREAM("MyClass")
    << "Failed to connect to server:" << serverAddress
    << ", port:" << port
    << ", error:" << socket->errorString();
```

---

## 性能考虑

### 1. 日志开销

- 日志输出会有性能开销（I/O操作）
- 在高频循环中避免过多日志
- 生产环境可考虑禁用DEBUG级别日志

### 2. 线程安全

- 日志系统使用 `QMutex` 确保线程安全
- 可在多线程环境中安全使用

---

## 高级用法

### 1. 动态模块名

当模块名需要动态生成时：

```cpp
class BaseMechanismController
{
private:
    QString m_name;  // 如 "FeedController"

public:
    void logState()
    {
        // 使用toStdString().c_str()转换QString
        LOG_INFO_STREAM(m_name.toStdString().c_str())
            << "State changed to:" << getCurrentState();
    }
};
```

---

### 2. 多行日志消息

```cpp
// 方法1：使用换行符
LOG_INFO("MyClass", "Multi-line log:\nLine 1\nLine 2\nLine 3");

// 方法2：多次调用（推荐，每行独立时间戳）
LOG_INFO("MyClass", "=== Configuration ===");
LOG_INFO_STREAM("MyClass") << "  Sample Rate:" << config.sampleRate;
LOG_INFO_STREAM("MyClass") << "  Buffer Size:" << config.bufferSize;
LOG_INFO("MyClass", "=====================");
```

---

## 未来改进计划

1. **日志文件输出** - 除控制台外，同时输出到文件
2. **日志过滤** - 运行时动态调整日志级别
3. **模块过滤** - 只显示特定模块的日志
4. **彩色输出** - 不同级别使用不同颜色（控制台支持ANSI时）
5. **性能统计** - 记录函数执行时间

---

## 常见问题

### Q1: 如何临时禁用某个模块的日志？

**方法1**：注释掉LOG调用
```cpp
// LOG_DEBUG("MyClass", "Debug message");
```

**方法2**：使用条件编译
```cpp
#ifndef DISABLE_MYCLASS_LOG
LOG_DEBUG("MyClass", "Debug message");
#endif
```

### Q2: 如何查看日志输出？

**开发环境（Qt Creator）**：
- 日志输出到"应用程序输出"窗口

**命令行运行**：
```bash
.\DrillControl.exe 2>&1 | tee log.txt  # 同时输出到控制台和文件
```

**Windows PowerShell**：
```powershell
.\DrillControl.exe 2>&1 | Tee-Object -FilePath log.txt
```

### Q3: 日志时间是本地时间还是UTC？

使用本地时间 (`QDateTime::currentDateTime()`)。

---

## 快速参考

| 宏名称 | 用途 | 示例 |
|-------|------|------|
| `LOG_DEBUG(module, msg)` | 调试信息 | `LOG_DEBUG("MyClass", "Debug")` |
| `LOG_INFO(module, msg)` | 一般信息 | `LOG_INFO("MyClass", "Started")` |
| `LOG_WARNING(module, msg)` | 警告信息 | `LOG_WARNING("MyClass", "Retry")` |
| `LOG_ERROR(module, msg)` | 错误信息 | `LOG_ERROR("MyClass", "Failed")` |
| `LOG_CRITICAL(module, msg)` | 严重错误 | `LOG_CRITICAL("MyClass", "Crash")` |
| `LOG_DEBUG_STREAM(module)` | 流式调试 | `LOG_DEBUG_STREAM("MyClass") << val` |
| `LOG_INFO_STREAM(module)` | 流式信息 | `LOG_INFO_STREAM("MyClass") << val` |
| `LOG_WARNING_STREAM(module)` | 流式警告 | `LOG_WARNING_STREAM("MyClass") << val` |
| `LOG_ERROR_STREAM(module)` | 流式错误 | `LOG_ERROR_STREAM("MyClass") << val` |
| `LOG_CRITICAL_STREAM(module)` | 流式严重 | `LOG_CRITICAL_STREAM("MyClass") << val` |

---

## 版本历史

### v1.0 (2025-01-18)
- 实现统一日志系统
- 格式：`[时间][级别][模块] 消息`
- 提供字符串和流式两种API
- 线程安全
- 全局消息处理器接管所有Qt日志

---

## 技术实现

### 核心文件

- `include/Logger.h` - 日志系统头文件，定义所有宏和类
- `src/Logger.cpp` - 日志系统实现
- `src/main.cpp` - 在main()中调用 `Logger::install()`

### 关键技术

- **Qt消息处理器**：`qInstallMessageHandler()` 接管所有日志
- **线程安全**：使用 `QMutex` 保护并发访问
- **零开销宏**：编译时展开，无运行时函数调用开销（宏本身）
- **RAII模式**：`LogStream` 使用析构函数自动输出

---

## 反馈与改进

如发现问题或有改进建议，请联系开发团队。
